// =======================================================================
// Essential CSS Concepts
// =======================================================================

// =======================================================================
// Build an NFT Site Intro

// =======================================================================
// Semantic HTML - Header, Main, Sector, Footer

// <header> - Site title, logo, and nav
// <section> - A stand-alone section
// <footer> - Copyright, Ts & Cs, ect.
// <main> The page's unique content

// =======================================================================
// Aside: Margins - strange behaviour

// When an element touches its parent, it;s top and bottom margins
// will merge with the margins of the parent element.

// This can be fixed by adding padding to the parent element.

// This is not an issue when you are using flexbox and grid.

// =======================================================================
// Grouping Selectors

// ID beats class, class beats element, element is last
// CSS reads top down
// element = 1 point
// class = 10 points
// id = 100 points

// =======================================================================
// CSS specificity and !important keyword

// =======================================================================
// Aside: buttons/links

// Buttons: For actions that affect the websites front-end or back-end

// Links: for navigation to somewhere on the same page, within the site, 
// or elsewhere on the internet.

// =======================================================================
// Aside: Inline-block

// Block elements
// Stack on top of each other.
// div, p, h1 are all examples of block elements.
// Set height and margin top and bottom

// Inline Elements
// Sit side by side
// span and a are examples of inline elements.
// cannot set height and margin top.

// =======================================================================
// Aside: Overflow

// overflow: hidden; hides excessive content. Useful for maintaining the
// layout but can elad to inaccessible content.

// overflow: scroll;
// adds a scrollbar to the tainer even if there is no overflow

// overflow: auto;
// only adds a scroll bar when needed.

// overflow-x and overflow-y
// control overflow behaviour seperately fopr horizontal and vertical
// content to some extent
// overflow-x: hidden and overflow-y: visible don't work together.

// =======================================================================
// CSS Fundamentals: Challenges
// =======================================================================

// =======================================================================
// CSS Fundamentals: Introduction

// =======================================================================
// CSS Fundamentals: Setting up the layout

// Add the image after the <h1>
// Remember to add alt!!!
// Center the text for the entire page
// Add a new div, give it a class, and assign it a width of 570px
// Center that div on the page

// Solution

body {
    text-align: center;
}

.container {
    width: 570px;
    margin: 0 auto;
}

// =======================================================================
// CSS Fundamentals: Google fonts

// Find 'Roboto' on Google fonts
// Make sure you get the "light" and the "black" weights
// Add the code needed to the HTML
// Set the font family for the entire page to Roboto

// =======================================================================
// CSS Fundamentals: Setting up the typography

// Font sizes
// h1: 60px
// h2: 42px
// h3: 36px
// body: 21px
// small: 16px

// Font weights
// black - 900
// body - 300

// =======================================================================
// CSS Fundamentals: Making things a little more fancy

// The title needs extra styling
// The link needs to be styled.

// h1: 80px
// h2: 60px
// bold must be on it's own line

//link color: #99D930
// link hover color: #131313

h1 span,
h2 span {
    font-weight: 900;
}

<span class="bold-text"></span>

.bold-text {
    font-weight: 900;
    display: block;
}

// =======================================================================
// CSS Fundamentals: Breathing Room

// Each "part" of the site needs 100px of space on the top and bottom

// Each "part" needs a different background color that extends the entire
// width of the viewport

// colors: #d7d7d7, #ffeaea, #eaf9ff    

// =======================================================================
// CSS Fundamentals: Playing with colors

// background color: #252525
// text color: #fff

// =======================================================================
// CSS Fundamentals: The finer details

// =======================================================================
// CSS Fundamentals: Creating buttons

// Include a hover and a focus state

// Use links rather than actual buttons

// normal state, background-color: #99d930, color: #252525
// hover state, background-color: #252525, color: #fff

// =======================================================================
// CSS Fundamentals: Fancier headings

// width 1px
// color #c4c4c4

// =======================================================================
// CSS Fundamentals: Working with what you have

### Instructions
#### All green text
- color: #99d930
- Font-weight: 900

####The headings
- h1: 80px
- h2: 60px

#### Button hover/focus
- background: #fff
- color: #252525


// =======================================================================
// Solo Project - Oldagram

// Create the first post
// Use semantic HTML
// Add hover effects to the icons

// stretch goal
// render out all of the posts using JS
// increase the likes when double clicking the post

// =======================================================================
// Build A Coworking Space Site
// =======================================================================

// =======================================================================
// Intro

// using margin: auto on flex children
// position: absolute & relative
// align-self
// position: fixed

// =======================================================================
// Aside: margin: auto on flexbox children

// <div class="meme-container" role="img" aria-label="A smiling dog">

// WHen setting position absolute and relative, it is the container,
// that should be set to postion: relative, and the element within the 
// container which should be set to absolute.
// Without the container set to relative, the element within the container,
// will just snap to the window. 

// =======================================================================
// Aside: Position Fixed

// Use position: absolute to position an element relative to a containing,
// element. The element scrolls with the content.

// Use position: fixed to lock an element in a position relative to the
// window. It maintains that position even when scrolling.

// =======================================================================
// Aside: z-index

// the z axis order of positioned elements and their descendants
// position: relative, absolute, fixed, sticky

// =======================================================================
// Essential JavaScript concepts
// =======================================================================

// =======================================================================
// Intro

// =======================================================================
// Cookie Consent Intro

// =======================================================================
// Position the modal

/*
Challenge:
1. Make the modal sit on top of the other content. 
2. Make sure it is centrally aligned both horizontally
   and vertically (just like in the slide).
3. When it's positioned correctly, set its display 
   property to 'none'.
*/

position: fixed;
top: 0;
bottom: 0;
left: 0;
right: 0;
margin: auto;

// =======================================================================
// Aside: setTimeout

// With setTimeout() you can remove a block of code from the regular flow
// of the program, and execute it at a later point.

/*
Challenge:
1. Make the third console.log fire 3 seconds after 
   the answer appears.
*/

setTimeout(() => console.log('Ready for next question?'), 6000

// =======================================================================
// Aside: element.style

/*
Challenge
1. When the button is clicked and the answer revealed, 
   change the background color to #68e1fd and text color
   to #1434A4 just in the "question" div.
   ‚ö†Ô∏è You will run into a problem with the background 
   color. See if you can find the solution by googling.
2. When the answer is revealed, make the button disappear.
*/

const revealBtn = document.getElementById('reveal-btn')
const answer = document.getElementById('answer')
const question = document.getElementById('question')

revealBtn.addEventListener('click', () =>{
    answer.style.display = 'block'
    revealBtn.style.display = 'none'
    
    question.style.backgroundColor = '#68e1fd'
    question.style.color = '#1434A4'
})

// =======================================================================
// Make the modal reappear

/*
Challenge:
1. Take control of the 'modal' div with JavaScript.
2. Swap out our console.log for a line of code
   which will change the CSS 'display' property
   of our modal to 'inline'.
*/

const modal = document.getElementById('modal')

setTimeout(() => modal.style.display = 'inline', 1500)

// =======================================================================
// Close the modal

/*
Challenge:
1. Take control of the close button.
2. Use an event listener to set the display 
   property of the modal to 'none' when the
   close button is clicked.
*/

const modal = document.getElementById('modal')
const modalBtn = document.getElementById('modal-close-btn')

setTimeout(() => modal.style.display = 'inline', 1500)

modalBtn.addEventListener('click', () => {
    modalBtn.style.display = 'none'
    modal.style.display = 'none'
})

// =======================================================================
// Aside: Forms

// Forms: Getting input from users

Challenge:
1. Add inputs for the email and password
   fields. Remember to add all necessary
   properties.
2. Give the inputs labels and make it so
   that clicking on the label brings the 
   corresponding input into focus.    
 -->

    <form>
    <label for="astronautName">Astronaut Name üë©‚ÄçüöÄ</label>
    <input
            type="text"
            id="astronautName"
            name="astronautName"
            placeholder="Neil Armstrong"
            >
    <label for="astronautEmail">Astronaut Email</label>
    <input
            type="email"
            id="astronautEmail"
            name="astronautEmail"
            placeholder="n.armstrong@nasa.com"
            >

    <label for="password">Password</label>
    <input
            type="password"
            id="password"
            name="password"
            placeholder="*******"
            >
    </form>

// =======================================================================
// Add a form 1

<!-- 
Challenge: 
1. Create a form using form tags.
2. Add two inputs: one for name and one 
   for email address.
3. Give each input "type", "name" and 
   "placeholder" properties. You can see the
   placeholder text we need in the slide. 
-->	

    <form>
        <input
            type="text"
            id="fullName"
            name="fullName"
            placeholder="Enter your full name"
            >
        <input
            type="email"
            id="emailAddress"
            name="emailAddress"
            placeholder="Enter your email"
            >
    </form>

// =======================================================================
// Aside Validation Attributes

<!-- Challenge:
1. Use 'min' and 'max' to make sure that only ages of 
   21 and over and 120 and under can be inputted.
  -->

    <input 
    required
    type="number" 
    id="astronautAge" 
    name="astronautAge"
    placeholder="21"
    min="21"
    max="120"
    >

// =================================

<!-- Challenge:
1. Make sure users can only input a 3 character country 
   code. These can be lower or upper case but exactly 
   3 characters in length and no special characters or
   numbers.
   
   USA, FRA, GBR, SWE ‚úÖ
   US, UK, AB1, !USA ‚ùå 
  -->

//  You can use the following regex to match a 3-letter country code, 
//  either uppercase or lowercase:

\b[a-zA-Z]{3}\b

// \b  Word boundary, ensures you're matching exactly 3-letter words 
// (not part of a longer word)

// [a-zA-Z] Matches one uppercase or lowercase letter

// {3} Exactly 3 of the previous pattern (i.e. 3 letters)

    <input 
        required
        type="text" 
        id="astronautCountryCode" 
        name="astronautCountryCode"
        placeholder="Fra"
        pattern="\b[a-zA-Z]{3}\b"
    > 

// =======================================================================
// Aside: preventDefault

const loginForm = document.getElementById('login-form')

loginForm.addEventListener('submit', function(e){
    e.preventDefault()
})

// =======================================================================
// preventDefault Challenge

/*
Challenge:
1. Take control of the form element. 
2. Add an eventListener to the form to listen for a
   "submit" event.
3. When a user clicks "accept", prevent the default
   behaviour that triggers the refresh.
4. Log out "form submitted".
*/  

consentForm.addEventListener('submit', (e) => {
    e.preventDefault()
    console.log('form submitted')
})

// =======================================================================
// Add modal message

/*
Challenge:
1. Take control of the "modal-text" element. 
2. Make it so that when a user clicks on 
   the accept button, the HTML string below
   is inserted into the modal-text div.

<div class="modal-inner-loading">
    <img src="images/loading.svg" class="loading">
    <p id="uploadText">
        Uploading your data to the dark web...
    </p>
</div>
*/ 

consentForm.addEventListener('submit', function(e){
    e.preventDefault()
    
    modalText.innerHTML = `<div class="modal-inner-loading">
    <img src="images/loading.svg" class="loading">
    <p id="uploadText">
        Uploading your data to the dark web...
    </p>
</div>`

})
 

// =======================================================================
// Add modal messages 2

/*   
Challenge: 
1. Use a setTimeout to make the phrase "Uploading
   your data to the dark web" change to "Making the 
   sale..." after 1.5 seconds.
‚ö†Ô∏è Do not change the loading svg!
*/   

consentForm.addEventListener('submit', function(e){
    e.preventDefault()
    modalText.innerHTML = `
    <div class="modal-inner-loading">
        <img src="images/loading.svg" class="loading">
        <p id="upload-text">Uploading your data to the dark web...</p>
    </div>` 
    
    setTimeout(function(){
        document.getElementById('upload-text').innerText = `Making the sale...`
    }, 1500) 

})

// =======================================================================
// Add modal messages 3

/*   
Challenge: 
1. Make it so that 1.5 seconds after seeing the 
    "Making the sale..." message, the modal is 
    cleared of its content and the following 
    string of HTML is displayed instead.
    
    `<h2>Thanks you sucker! </h2>
    <p>We just sold the rights to your eternal soul.</p>
    <div class="idiot-gif">
        <img src="images/pirate.gif">
    </div>
    ` 
*/

setTimeout(function(){
    document.getElementById('modal-inner').innerHTML = `
    <h2>Thanks you sucker! </h2>
    <p>We just sold the rights to your eternal soul.</p>
    <div class="idiot-gif">
        <img src="images/pirate.gif">
    </div>
` 
}, 3000)


// =======================================================================
// Aside: FormData

// Using FormData to store submitted form information into an object

const loginForm = document.getElementById('login-form')

loginForm.addEventListener('submit', function(e){
    e.preventDefault()
    
    const loginFormData = new FormData(loginForm)
    console.log(loginFormData)
})

// =======================================================================
// Form Data 1

/*   
Challenge: 
1. Inside the body of this event listener, 
   create a const and set it equals to a new 
   instance of FormData which takes in our HTML 
   form element as a parameter.
2. Log out the const (you should just get 
   a FormData object).
*/ 

const modalFormData = new FormData(consentForm)
console.log(modalFormData)

// =======================================================================
// Aside: FormData methods

// .get() - goes into the object and extracts the values specified.

<input 
    type="text" 
    id="astronautName" 
    name="astronautName"
    placeholder="Neil Armstrong"
    required
    >

const name = loginFormData.get('astronautName')
const email = loginFormData.get('astronautEmail')
const password = loginFormData.get('astronautPassword')
console.log(name) 

// =======================================================================
// Aside: Disabling elements

/*
Challenge:
1. Disable the 'Add to Cart' button when 
   quantity is at zero. Remember: quantity
   will be at zero when the page loads!
*/ 

// =======================================================================
// Disable the close button

modalCloseBtn.disabled = true

// =======================================================================
// Aside: classlist.toggle

<div class="container" id="container">

.reverse{
    flex-direction: row-reverse;
}

sortBtn.addEventListener('click', function(){
    container.classList.toggle('reverse')
})


// =======================================================================
// Pumpkin's Purrfect Meme Picker
// =======================================================================

// =======================================================================
// Aside: for of

const characters = [
    {
        title: 'Ninja',
        emoji: 'ü•∑',
        powers: ['agility', 'stealth', 'aggression'],
    },
    {
        title: 'Sorcerer',
        emoji: 'üßô',
        powers: ['magic', 'invisibility', 'necromancy'],
    },
    {
        title: 'Ogre',
        emoji: 'üëπ',
        powers: ['power', 'stamina', 'shapeshifting'],
    },
    {
        title: 'Unicorn',
        emoji: 'ü¶Ñ',
        powers: [ 'flight', 'power', 'purity'],
    }
]

/*
Challenge:
1. Nest a for of inside this for of to iterate over 
   the powers array for each character. Log out each 
   power.
*/

for (let character of characters){
    for (let power of character.powers){
        console.log(power)
    }
}

// magic
// invisibility
// necromancy...

// =======================================================================
// Use a for of

/*
Challenge:
1. Set up a "for of" in getEmotionsArray to iterate 
   over the data.
2. For now, just log out each cat object individually.
*/

const catsData = [
    {
        emotionTags: ["moody"],
        isGif: false,
        image: "angry.jpeg",
        alt: "A cat looking moody",
    },
    {
        emotionTags: ["moody", "insomniac"],
        isGif: false,
        image: "angry2.jpeg",
        alt: "A cat looking moody",
    },
    {
        emotionTags: ["moody"],
        isGif: false,
        image: "angry3.jpeg",
        alt: "A cat looking moody",
    },
    {
        emotionTags: ["confused", "sad"],
        isGif: false,
        image: "confused.jpeg",
        alt: "A cat looking confused",
    },
    {
        emotionTags: ["dominant", "moody"],
        isGif: false,
        image: "dominant.jpeg",
        alt: "A cat looking dominant",
    },
    {
        emotionTags: ["happy", "relaxed"],
        isGif: false,
        image: "happy.jpeg",
        alt: "A cat looking happy",
    },
    {
        emotionTags: ["hungry"],
        isGif: false,
        image: "hungry.jpeg",
        alt: "A cat looking hungry",
    },
    {
        emotionTags: ["hungry"],
        isGif: false,
        image: "hungry1.jpeg",
        alt: "A cat looking hungry",
    },
    {
        emotionTags: ["insomniac"],
        isGif: false,
        image: "insomnia.jpeg",
        alt: "A cat looking insomniac",
    },
    {
        emotionTags: ["insomniac"],
        isGif: false,
        image: "insomnia1.jpeg",
        alt: "A cat looking insomniac",
    },
    {
        emotionTags: ["relaxed"],
        isGif: false,
        image: "lazy.jpeg",
        alt: "A cat looking lazy",
    },
    {
        emotionTags: ["scared"],
        isGif: false,
        image: "nervous.jpeg",
        alt: "A cat looking nervous",
    },
    {
        emotionTags: ["sad"],
        isGif: false,
        image: "sad.jpeg",
        alt: "A cat looking sad",
    },
    {
        emotionTags: ["sad", "moody"],
        isGif: false,
        image: "sad1.jpeg",
        alt: "A cat looking sad",
    },
    {
        emotionTags: ["moody"],
        isGif: true,
        image: "angry.gif",
        alt: "A cat looking moody",
    },
    {
        emotionTags: ["moody"],
        isGif: true,
        image: "angry2.gif",
        alt: "A cat looking angry",
    },
    {
        emotionTags: ["confused"],
        isGif: true,
        image: "confused2.gif",
        alt: "A cat looking confused",
    },
    {
        emotionTags: ["dominant"],
        isGif: true,
        image: "dominant.gif",
        alt: "A cat looking dominant",
    },
    {
        emotionTags: ["happy"],
        isGif: true,
        image: "happy.gif",
        alt: "A cat looking happy",
    },
    {
        emotionTags: ["hungry", "sad", "confused"],
        isGif: true,
        image: "confused.gif",
        alt: "A cat looking hungry",
    },
    {
        emotionTags: ["hungry"],
        isGif: true,
        image: "hungry.gif",
        alt: "A cat looking hungry",
    },
    {
        emotionTags: ["hungry"],
        isGif: true,
        image: "hungry2.gif",
        alt: "A cat looking hungry",
    },
    {
        emotionTags: ["insomniac", "scared"],
        isGif: true,
        image: "insomnia2.gif",
        alt: "A cat looking insomniac",
    },
    {
        emotionTags: ["relaxed"],
        isGif: true,
        image: "lazy.gif",
        alt: "A cat looking relaxed",
    },
    {
        emotionTags: ["relaxed"],
        isGif: true,
        image: "relaxed2.gif",
        alt: "A cat looking relaxed",
    },
    {
        emotionTags: ["scared", "sad"],
        isGif: true,
        image: "nervous.gif",
        alt: "A cat looking nervous",
    },
    {
        emotionTags: ["scared"],
        isGif: true,
        image: "nervous2.gif",
        alt: "A cat looking scared",
    },
    {
        emotionTags: ["sad"],
        isGif: true,
        image: "sad.gif",
        alt: "A cat looking sad",
    },
]

function getEmotionsArray(cats){
    for (let cat of cats) {
        console.log(cat)
    }
}

getEmotionsArray(catsData)

// {emotionTags: ['moody'], isGif: false, image: 'angry.jpeg', alt: 'A cat looking moody'}
// {emotionTags: ['moody', 'insomniac'], isGif: false, image: 'angry2.jpeg', alt: 'A cat looking moody'}
// {emotionTags: ['moody'], isGif: false, image: 'angry3.jpeg', alt: 'A cat looking moody'}

// =======================================================================
// Nest the for of

/*
Challenge:
1. Add a nested "for of" to log out just 
   the emotions from the emotionTags array 
   in each object.
*/  

function getEmotionsArray(cats){
    for (let cat of cats){
        for (let emotions of cat.emotionTags)
        console.log(emotions)
    }
}

// ===============================

/*
Challenge:
1. Set up a const and initialise it with 
   an empty array.
2. Instead of logging out each emotion, 
   push each one to the new array.
3. At the end of the function, log out the 
   const holding the new array.
*/ 

function getEmotionsArray(cats){
    const emptyEmotionsArray = []
    for (let cat of cats){
        for (let emotion of cat.emotionTags){
            emptyEmotionsArray.push(emotion)
        }
        
    }
    console.log(emptyEmotionsArray)
}

// =======================================================================
// Render out the emotions 1

/*
Challenge:
1. Have the new function "renderEmotionsRadios" 
   take in a single parameter. Name that parameter
   "cats". 
2. Inside renderEmotionsRadios, set up a const called 
   "emotions" and set it equals to whatever is returned 
   by calling getEmotionsArray, passing in "cats" as an 
   argument.
3. For now, renderEmotionsRadios should just log out 
   "emotions".
4. Call renderEmotionsRadios passing in catsData.
*/

function renderEmotionsRadios(cats){
    const emotions = getEmotionsArray(cats)
    
    console.log(emotions)
}

renderEmotionsRadios(catsData)

// =======================================================================
// Render out the emotions 2

/*
Challenge:
1. Take control of the 'emotion-radios' div.
2. In renderEmotionsRadios, set up a let 
   to hold our string of HTML. You can initialise
   it with an empty string.
3. Iterate over "emotions" and put each emotion 
in a <p> tag and then add them to the let you 
created in step 2. 
4. Render the string to the 'emotion-radios' div.
*/ 

const emotionRadios = document.getElementById('emotion-radios')

function renderEmotionsRadios(cats){
    const emotions = getEmotionsArray(cats)
    
    let emotionsString = ''
    
    emotions.forEach((emotion) => emotionsString += `<p>${emotion}</p>`)
    
    emotionRadios.innerHTML = emotionsString
    
}

renderEmotionsRadios(catsData)

// ===============================

// Instructor Solution

function renderEmotionsRadios(cats){
    let radioItems = ``
    const emotions = getEmotionsArray(cats)
    for (let emotion of emotions){
        radioItems += `<p>${emotion}</p>`
    }
    emotionRadios.innerHTML = radioItems
}

// =======================================================================
// Import the data

// data.js 

export const catsData = []

// index.js

import { catsData } from '/data.js'

// =======================================================================
// Aside: Radio Inputs

    <div class="radio">
        <input 
        type="radio"
        id="horses"
        value="horses"
        name="choice-radios"
        >
        <label for="horses">5 duck-sized horses</label>
    </div>

// =======================================================================
// Render the radio inputs

/*
Challenge:
1. Swap out `<p>${emotion}</p>` for HTML
   that will render a radio input for each
   emotion. Remember to use "type", "id", 
   "value", and "name" properties on each radio.
   ("id" and "value" can both be set to the
   "emotion").
2. Remember to give each radio a label.
   (What property does a label need?)
3. Enclose each individual radio input in this div:
   <div class="radio">
      **RADIO HERE**
   </div>
*/ 

function renderEmotionsRadios(cats){
    
    let radioItems = ``
    const emotions = getEmotionsArray(cats)
    for (let emotion of emotions){

        radioItems += `<div class="radio">
           <input
           type="radio"
           id="${emotion}"
           value="${emotion}"
           name="emotion-radio"
           >
        <label for="${emotion}">${emotion}</label> 
        </div>`
        
    emotionRadios.innerHTML = radioItems
    }
}

// =======================================================================
// Aside: .includes()

// A method for checking if an array holds a given value. 
// Returns true || false

/*
Challenge:
1. Add an if else to the event listener's function.
2. Only add an item to the shoppingList array if it 
   is not already in the shoppingList array.
3. If an item is a duplicate, clear the input field
   and log out "no duplicates".
*/

addItemBtn.addEventListener('click', function(){
        if (!shoppingList.includes(itemInput.value)) {
            shoppingList.push(itemInput.value)
            render() 
        } else {
          itemInput.value = '' 
          console.log('no duplicates')
        }    
})

// Instructor Solution

addItemBtn.addEventListener('click', function(){
        if(shoppingList.includes(itemInput.value)){
            console.log('no duplicates')
        }
        else{
            shoppingList.push(itemInput.value)
            render()        
        }
        itemInput.value = '' 
})


// =======================================================================
// remove duplicates

/*
Challenge:
1. Refactor this nested for of so that an 
   emotion is only pushed to emotionsArray
   if it is not already in emotionsArray.
   Extra kudos if you use the "logical not"
   operator - feel free to google it!
*/

function getEmotionsArray(cats){
    const emotionsArray = []
        
    for (let cat of cats){
        for (let emotion of cat.emotionTags){
            if (!emotionsArray.includes(emotion)) {
                emotionsArray.push(emotion)
            }
        }
    }
    return emotionsArray
}

// =======================================================================
// Aside: e.target

container.addEventListener('click', function(e){
    console.log(e.target.id)
})


// =======================================================================
// Get the id of the clicked option

/*
Challenge:
1. Add an eventListener to emotionRadios that will listen 
   out for any *change* in our radio buttons. When it detects
   a change, it should log out the id of the element that 
   was selected.
‚ö†Ô∏èÔ∏è Ô∏èTÔ∏èhÔ∏èis won't work if the eventListener is listening out for a 
   'click'. Google what event to listen for - I've already 
   given you a clue!
*/

emotionRadios.addEventListener('change', (e) => {
    console.log(e.target.id)
})

// =======================================================================
// Aside: parentElement

// Accessing the parent when you know the children

container.addEventListener('click', function(e){
    console.log(document.getElementById(e.target.id).parentElement)
})

// <div class='product'>

container.addEventListener('click', function(e){
    document.getElementById(e.target.id).parentElement.style.backgroundColor = 'lightblue'
})

// =======================================================================
// Aside: classlist add/remove

/*
Challenge:
1. Remove the "unread" class from the 
   parentElement of the clicked element.
*/

document.addEventListener('click', function(e){

    document.getElementById(e.target.id).parentElement.classList.remove('unread')
    document.getElementById(e.target.id).parentElement.classList.add('read')
    
})

// =======================================================================
// Add colour to the selected emotion

/*
Challenge:
1. highlightCheckedOption should take control 
   of the selected radio input and add the CSS
   class of "highlight" to its classlist.
*/

emotionRadios.addEventListener('change', highlightCheckedOption)

function highlightCheckedOption(e){

    document.getElementById(e.target.id).classList.add('highlight')
}

// ===============================

/*
Challenge:
1. Change the code in line 8 so we add the 
   'highlight' class to the parent of the 
   selected input radio.
*/

emotionRadios.addEventListener('change', highlightCheckedOption)

function highlightCheckedOption(e){
    document.getElementById(e.target.id).parentElement.classList.add('highlight')

}

// =======================================================================
// Aside: getElementsByClassName

// Grabbing all elelemtns with a given class with one line of code

/*
Challenge:
1. Finish setting up this array of 
   elements with the "product" class.
2. Iterate over this array and remove 
   the "purchase" class and add the 
   "on-offer" class.
*/

const productsArray = document.getElementsByClassName('product')
for (let product of productsArray){
    product.classList.remove('purchased')
    product.classList.add('on-offer')
}

// =======================================================================
// Remove the highlight class

/*
Challenge:
1. Create an array of all items that have 
   the "radio" class.
2. Iterate over the array and remove the 
   "highlight" class from each one.
*/ 

function highlightCheckedOption(e){
    
    const radioArray = document.getElementsByClassName('radio')
    for (let radio of radioArray) {
        radio.classList.remove('highlight')
    }    
    
    document.getElementById(e.target.id).parentElement.classList.add('highlight')
}

// =======================================================================
// Aside: querySelector and why it's useful

// A more powerful way of grabbing elements

const submitBtn = document.getElementById('submit-btn')

submitBtn.addEventListener('click', function(){
    const checkedRadio = document.querySelector('input[type="radio"]:checked')
    console.log(checkedRadio.value)
})

// =======================================================================
// Connect the button

/*
Challenge:
1. Set up an eventlistener which calls a new
   function called "getMatchingCatsArray" when
   the "Get Image" button is clicked.
2. getMatchingCatsArray should save the value
   of the checked radio input to a const and 
   log out that const.
*/

const getMatchingCatsArray = (() => {
    const checkedRadio = document.querySelector('input[type="radio"]:checked').value
    console.log(checkedRadio)
})

getImageBtn.addEventListener('click', getMatchingCatsArray)

// =======================================================================
// Has an emotion been chosen?

/*
Challenge:
1. Add code to getMatchingCatsArray so 
   that the two existing lines of code 
   only run if an emotion has been selected.
*/

if (document.querySelector('input[type="radio"]:checked')) {
    const selectedEmotion = document.querySelector('input[type="radio"]:checked').value
    console.log(selectedEmotion)
}

// =======================================================================
// Aside: checkbox

// Getting a straight true or false form our users

<label for="accept-terms">
    I accept these terms and conditions
</label>
<input type="checkbox" id="accept-terms">

const continueBtn = document.getElementById('continue-btn')
const acceptTerms = document.getElementById('accept-terms')

continueBtn.addEventListener('click', function(){
    
    console.log(acceptTerms.checked)
})

// true

// ===============================

/*
Challenge:
1. Add a second checkbox to see if a user
   wants to be added to the mailing list.
2. If they do, log out "mail accepted" when 
   the continue button is clicked. If they
   don't, log out "mail not accapted."
*/

const continueBtn = document.getElementById('continue-btn')
const acceptTerms = document.getElementById('accept-terms')
const mailingBox = document.getElementById('mailing-list')

continueBtn.addEventListener('click', function(){
    
    if (acceptTerms.checked && mailingBox.checked){
        console.log("Terms accepted!")    
        console.log("mail accepted!")    
    } else if (acceptTerms.checked && !mailingBox.checked) {
        console.log("Terms accepted!")
        console.log("mail not accepted!")
    }
    else {
        console.log("Terms refused!")         
        console.log("mail not accepted!")
    }
})
// =======================================================================
// isGif

/*
Challenge:
1. Take control of the gifs only option checkbox.
2. Set up a const in getMatchingCatsArray to store 
   a boolean which will be set to true if the 
   "gifs only" option is checked and false if it's
   not. (Think what a good name for this const would 
   be.)
3. Log it out to check it's working.
*/

const getGifs = document.getElementById('gifs-only-option')

const getGifsCheck = getGifs.checked
console.log(getGifsCheck)

// =======================================================================
// Aside: filter()

// Getting only the elements we want from an array

/*
Challenge:
1. Get rid of the if statement and reduce the 
   logic in this function to just one line 
   of code.
*/

const adults = ages.filter((age) => age >= 18)

// ===============================

/*
Challenge:
1. Use the .filter method to create an array 
   called "children" which holds all of the ages 
   that are under 18.  
*/

const children = ages.filter((age) => age < 18)

// =======================================================================
// Aside: filter() 2

/*
Challenge:
1. Use the .filter() method to create an array
   of all of the thrillers.
*/

const thrillerGenre = series.filter(function(show){
    return show.genres.includes('thriller')
})

console.log(thrillerGenre)

// =======================================================================
// Find matches with .filter()

/*
Challenge:
1. Use the .filter() and .includes() methods to get 
   an array of cats which have the selected emotion
   in their emotionTags array. 
2. Store this array in a const and log it out to check
   it's working. Think: what would be a good name for the
   const?
*/  

const getMatchingEmotions = catsData.filter((emotion) => {
    return emotion.emotionTags.includes(selectedEmotion)
})

console.log(getMatchingEmotions)

// =======================================================================
// Animated GIFs Only

/*
Challenge:
1. Change the .filter() method's function so it returns an 
   array that only has GIFs if the 'GIFs only' option is 
   checked. If the 'GIFs only' option is not checked, it
   should return an array of all matches as it does now.
*/ 

const matchingCatsArray = catsData.filter(function(cat){
    if(isGif){
        return cat.emotionTags.includes(selectedEmotion) && cat.isGif
    }
    else{
        return cat.emotionTags.includes(selectedEmotion)
    }
    
})
console.log(matchingCatsArray)

// =======================================================================
// If there's only one cat...

/*
Challenge:
1. Set up an if to check if there is only one
   cat object in the array. If there is, log
   out that cat object (but not the whole array!)
   {}
   Test: "happy", animated GIFS only checked.
*/  

if (catsArray.length === 1) {
    catsArray.forEach((element) => {
        console.log(element)
    })
}

// =======================================================================
// If there's more than one cat

/*
Challenge:
1. If catsArray has more than one object, 
   select an object at random and log it out.
*/ 

function getSingleCatObject(){
    
    const catsArray = getMatchingCatsArray()
    
    if (catsArray.length === 1){
        console.log(catsArray[0])
    }
    else {
        const random = Math.floor(Math.random() * catsArray.length)
        console.log(catsArray[random])
    }
    
}

// =======================================================================
// RenderCat()

/*
Challenge:
1. Take the object that is returned by 
   getSingleCatObject and save it to a const 
   called "catObject".
2. Set memeModalInner‚Äôs innerHTML to the HTML 
   string below, remembering to insert the relevant 
   data from catObject to replace the UPPERCASE text.
3. Set memeModal‚Äôs display property to "flex". 
 
       `<img 
        class="cat-img" 
        src="./images/CAT IMAGE"
        alt="CAT ALT TEXT"
        >`
*/ 

function renderCat(){

    const catObject = getSingleCatObject()
    
    memeModalInner.innerHTML = 
    `
    <img 
        class="cat-img" 
        src="./images/${catObject.image}"
        alt="${catObject.alt}"
        >
    `

    memeModal.style.display = 'flex'
    
}

// =======================================================================
// Close the modal

/*
Challenge:
1. Wire up the X button in the modal so
   it closes the modal.
*/ 

const memeModalBtn = document.getElementById('meme-modal-close-btn')

memeModalBtn.addEventListener('click', () => {
    memeModal.style.display = 'none'
})


// =======================================================================
// Twimba: Twitter Clone
// =======================================================================

// =======================================================================
// Import the data

/*
Challenge:
1. Put all of the data in its own file called
   data.js, and export it back into index.js. 
   Make any changes to index.html that are
   necessary to make this work.
2. Log out tweetsData.
*/

// =======================================================================
// Aside: TextArea

// A multiline input field

<textarea 
    placeholder="Ask me anything!" 
    id="chat-input"></textarea>

textarea{
    width: 239px;
    height: 50px;
    margin: 0px;
    padding: 5px;
    resize: none;
}

<!-- 
Challenge
1. Add a textarea.
2. Give it placeholder text as shown in the 
   slide and an id of "tweet-input".
-->

// =======================================================================
// Tweet Boilerplate

/*
Challenge:
1. Use a "for of" to iterate over the data and 
   create HTML string for each tweet using the 
   boilerplate below. Replace UPPERCASE text
   with data from the tweets. 
2. Store this HTML in a let called "feedHtml".
3. Log out feedHtml.
4. Call getFeedHtml to check it's working.
*/  

{
    handle: `@TrollBot66756542 üíé`,
    profilePic: `images/troll.jpg`,
    likes: 27,
    retweets: 10,
    tweetText: `Buy Bitcoin, ETH Make üí∞üí∞üí∞ low low prices. 
        Guaranteed return on investment. HMU DMs open!!`,
    replies: [],
    isLiked: false,
    isRetweeted: false,
    uuid: '4b161eee-c0f5-4545-9c4b-8562944223ee',
}

// =======================================================================
// Tweet Boilerplate Challenge

function getFeedHtml() {
    
    let feedHtml = ''

    for (let data of tweetsData) {
        feedHtml += `<div class="tweet">
    <div class="tweet-inner">
        <img src="${data.profilePic}" class="profile-pic">
        <div>
            <p class="handle">${data.handle}</p>
            <p class="tweet-text">${data.tweetText}</p>
            <div class="tweet-details">
                <span class="tweet-detail">
                    ${data.replies.length}
                </span>
                <span class="tweet-detail">
                    ${data.likes}
                </span>
                <span class="tweet-detail">
                    ${data.retweets}
                </span>
            </div>   
        </div>            
    </div>
</div>`
    }

    console.log(feedHtml)
}

// =======================================================================
// Aside: forEach()

// A method for iterating over arrays

/*
Challenge:
1. Nest a forEach to log out each individual
   power in each characters powers array.
*/

characters.forEach(function(character){
    character.powers.forEach((power) => {
        console.log(power)
    })
})

characters.forEach(function(character, index){
    console.log(index, character.title)
})


// 0 Ninja
// 1 Sorcerer
// 2 Ogre
// 3 Unicorn

// =======================================================================
// Render the tweets to the feed

    /*
Challenge:
1. Take control of the ‚Äòfeed‚Äô div.
2. Render the HTML returned by the getFeedHtml 
   function to the 'feed' div. 
   See if you can do this with just one line of code!
*/

function render(){
    document.getElementById('feed').innerHTML = getFeedHtml()
}

// =======================================================================
// Aside: CDN Font Awesome

// CDN (Content delivery network)
// A remote service
// Provides assets to web applications
// E.g functions, styles, icons
// Gives us a snipper of code that will bring the asset into our application

<!-- 
Challenge:
1. Find the icons for location, email and calendar
   on Font Awesome and add them here. Use the
   slide to remind you what we are aiming for. 
-->

<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" 
integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" 
crossorigin="anonymous" referrerpolicy="no-referrer" />

<i class="fa-solid fa-house"></i>
<i class="fa-solid fa-location-dot"></i>
<i class="fa-solid fa-envelope"></i>
<i class="fa-solid fa-calendar-days"></i>

// =======================================================================
// Aside: Data attritbutes new

// Storing extra information in HTML elements

// data-unique-name = "your string"

<i class="fa-solid fa-share" data-share="image-1"></i>

// =======================================================================
// Aside: Data Attr JS and Challenge

document.addEventListener('click', function(e) {
    console.log(e.target.dataset.share)
})

<!--
Challenge:
1. Add a data attribute holding the id of the 
   image to the heart icon's tag'.	
-->

<i class="fa-solid fa-heart" data-heart="image-1"></i>

/*
Challenge:
2. Make clicking on the heart icon log out
   the id of the image.
*/

document.addEventListener('click', function(e) {
    if (e.target.dataset.share){
        console.log(e.target.dataset.share)
    }
    
    else if (e.target.dataset.heart) {
        console.log(e.target.dataset.heart)
    }

})

// =======================================================================
// Aside: Data Attributes Naming Issues

// Don't use uppercase letters when naming data-attributes in HTML

// Seperate words with dashes in the HTML
// USe camelCase in the JavaScript

// =======================================================================
// Like a tweet part 2: data attributes

// =======================================================================
// Like a tweet part 3: eventListener

/*
Challenge:
1. When a like icon is clicked, this function 
   should log out the contents of the 'data-like' 
   data-attribute.

‚ö†Ô∏è Clicking on the page but not on the like icon
   will log out 'undefined'. That is absolutely fine.
*/

document.addEventListener('click', function(e){
    if (e.target.dataset.like) {
        console.log(e.target.dataset.like)
    }
})

// =======================================================================
// Like a tweet part 4: handleClick()

/*
Challenge:
1. If a like icon has been clicked, call handleLikeClick
   passing in the uuid that is stored in the like icon's 
   data attribute. 
*/

document.addEventListener('click', function(e){

    if (e.target.dataset.like) {
      handleLikeClick(e.target.dataset.like)  
    }

})

/*
Challenge:
2. handleLikeClick should take in a parameter. 
   You can call this parameter 'tweetId'. For 
   now just log out tweetId.
*/

function handleLikeClick(tweetId){
    console.log(tweetId)
}

// =======================================================================
// Like a tweet part 5: find the tweet object

/*
Challenge:
1. Iterate over tweetsData and use the uuid 
   saved in tweetId to identify the liked
   tweet's object. Save that object to a 
   new const called 'targetTweetObj'.
‚ö†Ô∏è targetTweetObj should hold an object, NOT
   an array.
2. Increment targetTweetObj's 'likes' count 
   by 1.
3. Log out targetTweetObj.
*/

function handleLikeClick(tweetId){
    const targetTweetObj = tweetsData.find((tweet) => tweet.uuid === tweetId)
    
    if (targetTweetObj) {
        targetTweetObj.likes += 1
    }
    console.log(targetTweetObj)
}

// ===============================

// Instructors Solution

const targetTweetObj = tweetsData.filter(function(tweet){
    return tweet.uuid === tweetId
})[0]
targetTweetObj.likes++
console.log(tweetsData)

// =======================================================================
// Aside: Copying objects and arrays

// =======================================================================
// Like a tweet part 6: render the increment

function handleLikeClick(tweetId){ 
    const targetTweetObj = tweetsData.filter(function(tweet){
        return tweet.uuid === tweetId
    })[0]
    targetTweetObj.likes++
    render()
}

// =======================================================================
// Unlike a tweet

/*
Challenge:
1. When a tweet is liked, it's 'isLiked' property
   should be set to true.
2. When a tweet is unliked, it's 'isLiked' property
   should be set to false and its 'likes' count
   should be decremented.
*/  

function handleLikeClick(tweetId){ 
    const targetTweetObj = tweetsData.filter(function(tweet){
        return tweet.uuid === tweetId
    })[0]
    
    if (targetTweetObj.isLiked === false) {
        targetTweetObj.isLiked = true
        targetTweetObj.likes++   
    } else {
        targetTweetObj.isLiked = false
        targetTweetObj.likes--   
    }
    render()
}

// =======================================================================
// Flip a boolean

/*
Challenge:
1. Delete the two lines of code marked below and
   replace them with just one line of code outside 
   of the if else.
   Hint: Google the logical NOT operator (!)
*/ 

if (targetTweetObj.isLiked){
    targetTweetObj.likes--
}
else{
    targetTweetObj.likes++ 
}
targetTweetObj.isLiked = !targetTweetObj.isLiked

// =======================================================================
// Retweet a tweet

/*
Challenge:
1. Make this eventListener call "handleRetweetClick" 
   when the retweet icon is clicked, passing in the
   uuid from that tweet.  
*/

/*
Challenge:
2. Find the retweeted tweet's object in tweetsData 
   and save it to a const.
3. Increment or decrement the retweet count of the 
   tweet and flip its isRetweeted boolean.
4. Call the render function.  
*/   

function handleRetweetClick(tweetId){
    const targetTweetObj = tweetsData.filter(tweet => tweet.uuid === tweetId)[0]

    if (targetTweetObj.isRetweeted){
        targetTweetObj.retweets--
    }   else {
        targetTweetObj.retweets++
    }
    targetTweetObj.isRetweeted = !targetTweetObj.isRetweeted
    render()
}

// =======================================================================
// Aside: Conditionally render CSS class

// Giving elements different clases under different conditions


// =======================================================================
// Color the icons

/*
Challenge:
1. Use an if statement to set the value of 
   'likeIconClass' to the string 'liked' 
   if the tweet has been liked. 
2. In the like icon tag, add 'likeIconClass' 
   to the list of classes.
*/  

/*
Challenge:
1. Use an if statement to set the value of 
   'retweetIconClass' to the string 
   'retweeted' if the tweet has been retweeted. 
2. In the retweet icon tag, add 'retweetIconClass' 
   to the list of classes.
*/

// =======================================================================
// Replies 1: get uuids of tweets with replies

    /*
Challenge:
1. Use an if statement to check if a tweet has replies.
2. If it does, log out the uuid for that tweet.
*/

// =======================================================================
// Replies 2: HTML string for replies and add to parent div

/*
Challenge:
1. If a tweet has replies, iterate through the replies
   and wrap each one in the HTML template provided below. 
   Make sure to replace words in UPPERCASE with data from 
   the tweet. On each iteration, add this HTML to repliesHtml.
   
<div class="tweet-reply">
    <div class="tweet-inner">
        <img src="PROFILE PIC" class="profile-pic">
            <div>
                <p class="handle">HANDLE</p>
                <p class="tweet-text">TWEET TEXT</p>
            </div>
        </div>
</div>
*/

if (tweet.replies.length > 0) {
    tweet.replies.forEach((reply) => {
        repliesHtml += `<div class="tweet-reply">
        <div class="tweet-inner">
            <img src="${reply.profilePic}" class="profile-pic">
                <div>
                    <p class="handle">${reply.handle}</p>
                    <p class="tweet-text">${reply.tweetText}</p>
                </div>
            </div>
    </div>`
    })
}

// =======================================================================
// Replies 3: toggle hidden

/*
Challenge:
1. Use the uuid stored in 'replyId' to take control 
   of the div containing that tweet‚Äôs replies. 
   (Check the HTML string below to remind yourself 
   what id that div will have.)  
2. Toggle the CSS class "hidden" on that div. 
*/ 

function handleReplyClick(replyId){ 
    document.getElementById(`replies-${replyId}`).classList.toggle('hidden')  
}

// =======================================================================
// Refactor the tweet btn

/*
Challenge:
1. Add an else if so that if the Tweet button
   is clicked, handleTweetBtnClick is called.
*/ 

else if (e.target === tweetBtn) {
    handleTweetBtnClick()
}

// =======================================================================
// Aside: UUID

import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
console.log(uuidv4()) // 1dbea420-b8fd-4839-88a3-51f3a24573fb

// =======================================================================
// Build the new Tweet object

/*
Challenge:
2. When the Tweet button is clicked, log out an object
   for a new tweet. Make sure you include the text of 
   the tweet (how can you get that?) and a unique 
   identifier using uuidjs.
   
   The handle @Scrimba (or whatever you prefer) and 
   the profile pic scrimbalogo.png can be hard-coded.
*/ 

console.log({
    handle: `@Scrimba`,
    profilePic: `images/scrimbalogo.png`,
    likes: 0,
    retweets: 0,
    tweetText: `tweetInput.value,
    replies: [],
    isLiked: false,
    isRetweeted: false,
    uuid: uuidv4()})
    

// =======================================================================
// Render a new tweet

/*
Challenge:
1. Add the new tweet object to 'tweetsData'
   and make it render at the top of the feed. 
*/ 

function handleTweetBtnClick(){
    tweetsData.unshift ({
        handle: `@Scrimba`,
        profilePic: `images/scrimbalogo.png`,
        likes: 0,
        retweets: 0,
        tweetText: tweetInput.value,
        replies: [],
        isLiked: false,
        isRetweeted: false,
        uuid: uuidv4()
    })
    render()
}

// =======================================================================
// UX fixes

/*
Challenge:
1. No empty tweets!
2. Clear the textarea after tweeting!
*/

function handleTweetBtnClick(){
    if (!tweetInput.value) {
        return
    } else {
        tweetsData.unshift({
            handle: `@Scrimba`,
            profilePic: `images/scrimbalogo.png`,
            likes: 0,
            retweets: 0,
            tweetText: tweetInput.value,
            replies: [],
            isLiked: false,
            isRetweeted: false,
            uuid: uuidv4()
        })  
    }
    tweetInput.value = ''
    render() 
}

// ===============================

// Instructor Solution

function handleTweetBtnClick(){
/*
Challenge:
1. No empty tweets!
2. Clear the textarea after tweeting!
*/
    if(tweetInput.value){
        tweetsData.unshift({
            handle: `@Scrimba`,
            profilePic: `images/scrimbalogo.png`,
            likes: 0,
            retweets: 0,
            tweetText: tweetInput.value,
            replies: [],
            isLiked: false,
            isRetweeted: false,
            uuid: uuidv4()
        })
    render()
    tweetInput.value = ''
    }

}

// =======================================================================
// Recap

// Add the ability to reply to a specific tweet
// Save tweets, likes and retweets to localStorage
// Allow a user to delete a tweet
// Your own idea, dark / light

// =======================================================================
// Deploy Twimba



